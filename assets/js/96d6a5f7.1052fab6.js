"use strict";(self.webpackChunkapache_streampark_website=self.webpackChunkapache_streampark_website||[]).push([[5683],{15680:(e,t,n)=>{n.d(t,{xA:()=>u,yg:()=>h});var a=n(96540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(n),m=r,h=p["".concat(l,".").concat(m)]||p[m]||d[m]||o;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},19365:(e,t,n)=>{n.d(t,{A:()=>i});var a=n(96540),r=n(20053);const o={tabItem:"tabItem_Ymn6"};function i(e){let{children:t,hidden:n,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.A)(o.tabItem,i),hidden:n},t)}},11470:(e,t,n)=>{n.d(t,{A:()=>w});var a=n(58168),r=n(96540),o=n(20053),i=n(23104),s=n(56347),l=n(57485),c=n(31682),u=n(89466);function p(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}function d(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??p(n);return function(e){const t=(0,c.X)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const a=(0,s.W6)(),o=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l.aZ)(o),(0,r.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(a.location.search);t.set(o,e),a.replace({...a.location,search:t.toString()})}),[o,a])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,o=d(e),[i,s]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:o}))),[l,c]=h({queryString:n,groupId:a}),[p,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,o]=(0,u.Dv)(n);return[a,(0,r.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:a}),g=(()=>{const e=l??p;return m({value:e,tabValues:o})?e:null})();(0,r.useLayoutEffect)((()=>{g&&s(g)}),[g]);return{selectedValue:i,selectValue:(0,r.useCallback)((e=>{if(!m({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);s(e),c(e),f(e)}),[c,f,o]),tabValues:o}}var g=n(92303);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(e){let{className:t,block:n,selectedValue:s,selectValue:l,tabValues:c}=e;const u=[],{blockElementScrollPositionUntilNextRender:p}=(0,i.a_)(),d=e=>{const t=e.currentTarget,n=u.indexOf(t),a=c[n].value;a!==s&&(p(t),l(a))},m=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=u.indexOf(e.currentTarget)+1;t=u[n]??u[0];break}case"ArrowLeft":{const n=u.indexOf(e.currentTarget)-1;t=u[n]??u[u.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.A)("tabs",{"tabs--block":n},t)},c.map((e=>{let{value:t,label:n,attributes:i}=e;return r.createElement("li",(0,a.A)({role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,key:t,ref:e=>u.push(e),onKeyDown:m,onClick:d},i,{className:(0,o.A)("tabs__item",y.tabItem,i?.className,{"tabs__item--active":s===t})}),n??t)})))}function v(e){let{lazy:t,children:n,selectedValue:a}=e;const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},o.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function S(e){const t=f(e);return r.createElement("div",{className:(0,o.A)("tabs-container",y.tabList)},r.createElement(b,(0,a.A)({},e,t)),r.createElement(v,(0,a.A)({},e,t)))}function w(e){const t=(0,g.A)();return r.createElement(S,(0,a.A)({key:String(t)},e))}},59172:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>p});var a=n(58168),r=(n(96540),n(15680)),o=n(11470),i=n(19365);const s={id:"HTTP-Connector",title:"HTTP Connector",original:!0,sidebar_position:7},l=void 0,c={unversionedId:"connector/HTTP-Connector",id:"connector/HTTP-Connector",title:"HTTP Connector",description:"Some background services receive data through HTTP requests. In this scenario, Apache Flink can write result data through HTTP",source:"@site/docs/connector/7-http.md",sourceDirName:"connector",slug:"/connector/HTTP-Connector",permalink:"/docs/connector/HTTP-Connector",draft:!1,editUrl:"https://github.com/apache/incubator-streampark-website/edit/dev/docs/connector/7-http.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{id:"HTTP-Connector",title:"HTTP Connector",original:!0,sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Apache HBase Connector",permalink:"/docs/connector/HBase-Connector"},next:{title:"Redis Connector",permalink:"/docs/connector/Redis-Connector"}},u={},p=[{value:"http asynchronous write",id:"http-asynchronous-write",level:2},{value:"Write with Apache StreamPark\u2122",id:"write-with-apache-streampark",level:2},{value:"http asynchronous write support type",id:"http-asynchronous-write-support-type",level:3},{value:"Configuration list of HTTP asynchronous write",id:"configuration-list-of-http-asynchronous-write",level:3},{value:"HTTP writes data asynchronously",id:"http-writes-data-asynchronously",level:3},{value:"Other configuration",id:"other-configuration",level:2}],d={toc:p},m="wrapper";function h(e){let{components:t,...n}=e;return(0,r.yg)(m,(0,a.A)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("p",null,"Some background services receive data through HTTP requests. In this scenario, Apache Flink can write result data through HTTP\nrequests. Currently, Apache Flink officially does not provide a connector for writing data through HTTP requests. Apache StreamPark\nencapsulates HttpSink to write data asynchronously in real-time based on asynchttpclient."),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"HttpSink")," writes do not support transactions, writing data to the target service provides AT_LEAST_ONCE semantics. Data\nthat fails to be retried multiple times will be written to external components (Apache Kafka, MySQL, HDFS, Apache HBase), and the data\nwill be restored manually to achieve final data consistency."),(0,r.yg)("h2",{id:"http-asynchronous-write"},"http asynchronous write"),(0,r.yg)("p",null,"Asynchronous writing uses asynchttpclient as the client, you need to import the jar of asynchttpclient first."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-xml"},"<dependency>\n    <groupId>org.asynchttpclient</groupId>\n    <artifactId>async-http-client</artifactId>\n    <optional>true</optional>\n</dependency>\n")),(0,r.yg)("h2",{id:"write-with-apache-streampark"},"Write with Apache StreamPark\u2122"),(0,r.yg)("h3",{id:"http-asynchronous-write-support-type"},"http asynchronous write support type"),(0,r.yg)("p",null,"HttpSink supports get, post, patch, put, delete, options, trace of http protocol. Corresponding to the method of\nthe same name of HttpSink, the specific information is as follows:"),(0,r.yg)(i.A,{value:"Scala",label:"Scala",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},"class HttpSink(@(transient@param) ctx: StreamingContext,\n               header: Map[String, String] = Map.empty[String, String],\n               parallelism: Int = 0,\n               name: String = null,\n               uid: String = null) extends Sink {\n\n  def get(stream: DataStream[String]): DataStreamSink[String] = sink(stream, HttpGet.METHOD_NAME)\n\n  def post(stream: DataStream[String]): DataStreamSink[String] = sink(stream, HttpPost.METHOD_NAME)\n\n  def patch(stream: DataStream[String]): DataStreamSink[String] = sink(stream, HttpPatch.METHOD_NAME)\n\n  def put(stream: DataStream[String]): DataStreamSink[String] = sink(stream, HttpPut.METHOD_NAME)\n\n  def delete(stream: DataStream[String]): DataStreamSink[String] = sink(stream, HttpDelete.METHOD_NAME)\n\n  def options(stream: DataStream[String]): DataStreamSink[String] = sink(stream, HttpOptions.METHOD_NAME)\n\n  def trace(stream: DataStream[String]): DataStreamSink[String] = sink(stream, HttpTrace.METHOD_NAME)\n\n  private[this] def sink(stream: DataStream[String], method: String): DataStreamSink[String] = {\n    val params = ctx.parameter.toMap.filter(_._1.startsWith(HTTP_SINK_PREFIX)).map(x => x._1.drop(HTTP_SINK_PREFIX.length + 1) -> x._2)\n    val sinkFun = new HttpSinkFunction(params, header, method)\n    val sink = stream.addSink(sinkFun)\n    afterSink(sink, parallelism, name, uid)\n  }\n}\n\n"))),(0,r.yg)("h3",{id:"configuration-list-of-http-asynchronous-write"},"Configuration list of HTTP asynchronous write"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-yaml"},"http.sink:\n  threshold:\n    numWriters: 3\n    queueCapacity: 10000 #The maximum capacity of the queue, according to the size of a single record, and the size of the queue is estimated by itself. If the value is too large, the upstream data source is coming too fast, and the downstream write data may not keep up with OOM.\n    timeout: 100 #Timeout for sending http requests\n    retries: 3 #Maximum number of retries when sending fails\n    successCode: 200 #Send success status code\n  failover:\n    table: record\n    storage: mysql #kafka,hbase,hdfs\n    jdbc:\n      jdbcUrl: jdbc:mysql://localhost:3306/test\n      username: root\n      password: 123456\n    kafka:\n      topic: bigdata\n      bootstrap.servers: localhost:9091,localhost:9092,localhost:9093\n    hbase:\n      zookeeper.quorum: localhost\n      zookeeper.property.clientPort: 2181\n    hdfs:\n      namenode: hdfs://localhost:8020 # namenode rpc address and port, e.g: hdfs://hadoop:8020 , hdfs://hadoop:9000\n      user: benjobs # user\n      path: /http/failover # save path\n      format: yyyy-MM-dd\n")),(0,r.yg)("h3",{id:"http-writes-data-asynchronously"},"HTTP writes data asynchronously"),(0,r.yg)("p",null,"The program sample is scala"),(0,r.yg)(o.A,{mdxType:"Tabs"},(0,r.yg)(i.A,{value:"Scala",label:"Scala",mdxType:"TabItem"},(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scala"},'\nimport org.apache.streampark.flink.core.scala.FlinkStreaming\nimport org.apache.streampark.flink.core.scala.sink.HttpSink\nimport org.apache.flink.api.scala._\nimport org.apache.flink.streaming.api.scala.DataStream\n\nobject HttpSinkApp extends FlinkStreaming {\n\n  override def handle(): Unit = {\n\n    val source = context.addSource(new TestSource)\n\n    val value: DataStream[String] = source.map(x => s"http://127.0.0.1:8080?userId=(${x.userId}&siteId=${x.siteId})")\n    HttpSink().post(value).setParallelism(1)\n\n  }\n}\n\n')))),(0,r.yg)("admonition",{title:"warn",type:"info"},(0,r.yg)("p",{parentName:"admonition"},"Since http can only write one piece of data at a time, the latency is relatively high, and it is not suitable for\nwriting large amounts of data.   It is necessary to set a reasonable threshold to improve performance.\nSince httpSink asynchronous writing fails, data will be added to the cache queue again, which may cause data in the same\nwindow to be written in two batches.   It is recommended to fully test in scenarios with high real-time requirements.\nAfter the asynchronous write data reaches the maximum retry value, the data will be backed up to the external component, and the component connection will be initialized at this time. It is recommended to ensure the availability of the failover component.")),(0,r.yg)("h2",{id:"other-configuration"},"Other configuration"),(0,r.yg)("p",null,"All other configurations must comply with the ",(0,r.yg)("strong",{parentName:"p"},"StreamPark")," configuration.\nFor specific configurable items and the role of each parameter, please refer ",(0,r.yg)("a",{parentName:"p",href:"/docs/development/config/"},"Project configuration")))}h.isMDXComponent=!0}}]);